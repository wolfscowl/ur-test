def vgc10():

  vg_index = 0
  vg_dataRead_running = False
  vg_device_id_arr = [0, 0, 0]
  vg_product_code_arr = [0, 0, 0]
  vg_Limit_ma_arr = [0, 0, 0]
  vg_Vacuum_A_arr = [0, 0, 0]
  vg_Vacuum_B_arr = [0, 0, 0]
  vg_Vacuum_AB_arr = [0, 0, 0, 0, 0, 0]
  vg_mass_A_arr = [0, 0, 0]
  vg_mass_B_arr = [0, 0, 0]
  vg_vacuum_guard_arr = [False, False, False, False, False, False]
  vg_enabled_arr = [False, False, False]
  vg_error_title = "OnRobot - VG error"
  vg_device_id_waiting = "Waiting for valid OnRobot VG ID..."
  vg_device_id_timeout = "Waiting for valid OnRobot VG ID timed out.<br>Program halted."
  vg_status_error_title = "OnRobot - VG Status error"
  vg_status_error_missing = "Communication problem with a VG gripper. Please check the device.<br>Program halted."


  VG_DEVICE_ID_VG10 = 16
  VG_DEVICE_ID_VGC10 = 17

  ON_CONN_SHIFT_BOOL = 64
  ON_CONN_SHIFT_INT = 24
  ON_CONN_SHIFT_FLOAT = 24
  ON_CONN_REG_SUM_BOOL = 0
  ON_CONN_REG_SUM_INT = 4
  ON_CONN_REG_SUM_FLOAT = 2
  ON_TOOL_SHIFT_BOOL = 64
  ON_TOOL_SHIFT_INT = 25
  ON_TOOL_SHIFT_FLOAT = 24
  ON_TOOL_SHIFT_BOOL_ARR = [64, 64, 64]
  ON_TOOL_SHIFT_INT_ARR = [25, 28, 28]
  ON_TOOL_SHIFT_FLOAT_ARR = [24, 26, 26]
  ON_TOOL_REG_SUM_BOOL = 0
  ON_TOOL_REG_SUM_INT = 3
  ON_TOOL_REG_SUM_FLOAT = 2
  ON_REGISTERS_SPEEDL_FLOAT = 0
  ON_REG_USE_TOOL = False
  ON_DI_SINGLE = 0
  ON_DI_PRIMARY = 1
  ON_DI_SECONDARY = 2
  ON_DI_DUAL = 3

  on_conn_ip = "192.168.12.146"
  on_tool_ip = "192.168.12.146"
  on_devices = 1
  on_follow_tcp = False
  ON_INIT_WATCHDOG_HZ = 5
  ON_INIT_TIMEOUT = 2000
  on_device_socket_port = 51234
  on_conn_xmlrpc = rpc_factory("xmlrpc", "http://192.168.12.146:41414")
  on_tool_xmlrpc = rpc_factory("xmlrpc", "http://192.168.12.146:41414")
  on_conn_rtde_feed_name = "rtdeFeedConn"
  on_tool_rtde_feed_name = "rtdeFeedTool"
  ON_DEBUG_LOG = False
  on_xmlrpc_start_ip = "Connecting to OnRobot XML-RPC Server:"

  ON_ZEROFRAME = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  on_tcp_offset_actual = ON_ZEROFRAME
  on_tcp_offset_primary = ON_ZEROFRAME
  on_tcp_offset_secondary = ON_ZEROFRAME
  on_tcp_static_primary = ON_ZEROFRAME
  on_tcp_static_secondary = ON_ZEROFRAME

  on_portopened_javaSocket = False
  on_rtde_feed_opened = False
  on_dataProcess_running = False

  on_xmlrpc_start_ip="Connecting to OnRobot XML-RPC Server:"
  on_rtde_feed_error_textmsg_title = "OnRobot - RTDE error:"
  on_rtde_feed_error = "RTDE feed error. OnRobot device count mismatch.<br>Program halted."
  on_rtde_feed_tool_error = "Tool RTDE feed error. OnRobot device count mismatch.<br>Program halted."
  on_rtde_feed_open_error_textmsg = "Socket 'rtdeFeed' opening was unsuccessful."
  on_rtde_feed_error_title = "OnRobot - RTDE error"
  on_rtde_feed_count_error = "Invalid RTDE offset setup detected. Please check RTDE Offsets at the OnRobot Setup page in the Installation Tab.<br>Program halted."
  on_rtde_feed_open_error = "Establishing connection with the devices was timed out.<br>Ensure that the OnRobot devices are operational, and check the status in the OnRobot Setup page in the Installation Tab."

  # ===================== RTDE FEED - START ========================== #


  def on_rtde_feed_close(rtdeFeedName):
    socket_close(rtdeFeedName)
    on_rtde_feed_opened = False
  end


  def on_rtde_feed_open(deviceIP, rtdeFeedName, regStart, regSum, regSpeedl):
    on_rtde_feed_close(rtdeFeedName)
    if ((regStart[0] + regSum[0]) > 128) or ((regStart[1] + regSum[1]) > 48) or ((regStart[2] + regSum[2]) > 48):
      popup(on_rtde_feed_count_error, title = on_rtde_feed_error_title, error = True, blocking = False)
      textmsg(str_cat("RegStart: ", regStart), str_cat("  -  RegSum: ", regSum))
      halt
    end
    on_rtde_feed_opened = socket_open(deviceIP, on_device_socket_port, rtdeFeedName)
    if not on_rtde_feed_opened:
      on_rtde_feed_opened = socket_open(deviceIP, on_device_socket_port, rtdeFeedName)
    end
    if not on_rtde_feed_opened:
      textmsg(on_rtde_feed_error_textmsg_title, on_rtde_feed_open_error_textmsg)
      popup(on_rtde_feed_open_error, title = on_rtde_feed_error_title, error = True, blocking = False)
      halt
    end
    socket_send_int(regStart[0], rtdeFeedName)
    socket_send_int(regSum[0], rtdeFeedName)
    socket_send_int(regStart[1], rtdeFeedName)
    socket_send_int(regSum[1], rtdeFeedName)
    socket_send_int(regStart[2], rtdeFeedName)
    socket_send_int(regSum[2], rtdeFeedName)
    socket_send_int(regSpeedl, rtdeFeedName)
    socket_send_int(on_devices, rtdeFeedName)
  end


  def on_set_rtde_watchdog(updateHz = ON_INIT_WATCHDOG_HZ):
    local effect = "stop"
    if (updateHz < 1):
      effect = "ignore"
    end
    watchdog_conn_reg_str = str_cat("input_int_register_", ON_CONN_SHIFT_INT)
    rtde_set_watchdog(watchdog_conn_reg_str, updateHz, effect)
    if (ON_REG_USE_TOOL):
      watchdog_tool_reg_str = str_cat("input_int_register_", ON_TOOL_SHIFT_INT_ARR[0])
      rtde_set_watchdog(watchdog_tool_reg_str, updateHz, effect)
    end
    if ON_DEBUG_LOG:
      local update_str = str_cat(" " + effect + " watchdog set to [Hz]: ", updateHz)
      textmsg(watchdog_conn_reg_str, update_str)
      if (ON_REG_USE_TOOL):
        local update_str = str_cat(" " + effect + " watchdog set to [Hz]: ", updateHz)
        textmsg(watchdog_tool_reg_str, update_str)
      end
    end
  end


  # ===================== RTDE FEED - END ============================ #
  # ===================== DATA READ - START ========================== #


  def vg_dataRead_RTDE(tool_index):
    local reg_offset_bool = ON_TOOL_SHIFT_BOOL_ARR[tool_index]
    local reg_offset_int = ON_TOOL_SHIFT_INT_ARR[tool_index]
    local reg_offset_float = ON_TOOL_SHIFT_FLOAT_ARR[tool_index]
    enter_critical
      floatRegDummy = read_input_float_register(reg_offset_float + 0)
      vg_Vacuum_A_arr[tool_index] = floatRegDummy
      floatRegDummy = read_input_float_register(reg_offset_float + 1)
      vg_Vacuum_B_arr[tool_index] = floatRegDummy
      intRegDummy = read_input_integer_register(reg_offset_int + 0)
      vg_device_id_arr[tool_index] = intRegDummy
      intRegDummy = read_input_integer_register(reg_offset_int + 1)
      vg_product_code_arr[tool_index] = intRegDummy
      intRegDummy = read_input_integer_register(reg_offset_int + 2)
      vg_Limit_ma_arr[tool_index] = intRegDummy
    exit_critical
  end


  thread vg_dataRead_thread():
    if ON_DEBUG_LOG:
      textmsg("Starting vg_dataRead thread")
    end
    while vg_dataRead_running:
      sync()
      if (vg_index == ON_DI_DUAL):
        vg_dataRead_RTDE(ON_DI_PRIMARY)
        vg_dataRead_RTDE(ON_DI_SECONDARY)
      else:
        vg_dataRead_RTDE(vg_index)
      end
    end
    if ON_DEBUG_LOG:
      textmsg("Stopping vg_dataRead thread")
    end
  end


  # ===================== DATA READ - END ============================ #
  # ===================== TCP DEF - START ============================ #


  def on_get_tcp_for(tool_index):
    if tool_index == ON_DI_SECONDARY:
      local actual_tcp = on_tcp_static_secondary
    else:
      local actual_tcp = on_tcp_static_primary
    end
    return actual_tcp
  end


  # ===================== TCP DEF - END ============================== #
  # ===================== ACTION DEF - START ========================= #

  vg_grip_message_title = "OnRobot - VG Grip"
  vg_grip_delayed_init_fail = "Failed to initialize delayed VG Grip.<br>Program halted."
  vg_grip_delayed_start_fail = "Failed to start delayed VG Grip.<br>Program halted."
  vg_grip_bad_arg_channel = "vg_grip argument error : Please select channel 0, 1 or 2"
  vg_grip_bad_arg_vacuum = "vg_grip : Vacuum should be between 0 and 80"
  vg_grip_error_command = "Could not send grip command<br>Please check connection.<br>Program halted."
  vg_grip_could_not_reach_vacuum = "Could not reach requested vacuum.<br>Please check robot/workpiece alignment and suction cups.<br>Program halted."
  vg_grip_no_part = "No part found while seeking."

  VG_GRIP_DELEAYED_STATUS_IDLE = 0
  VG_GRIP_DELEAYED_STATUS_INIT = 1
  VG_GRIP_DELEAYED_STATUS_START = 2
  vg_grip_delay = 0
  vg_grip_delayed_channel = 2
  vg_grip_delayed_vacuum = 60
  vg_grip_delayed_timeout = 3.0
  vg_grip_delayed_alert = True
  vg_grip_delayed_mass = 0
  vg_grip_delayed_status = 0
  vg_grip_delayed_tool_index = 0
  vg_grip_delayed_thread_handler = [0, 0, 0]


  def vg10_grip(channel = 2, vacuum = 60, timeout = 3.0, alert = True, tool_index = 0):
    vg_grip(channel, vacuum, timeout, alert, tool_index)
  end


  def vg_grip(channel = 2, vacuum = 60, timeout = 3.0, alert = True, tool_index = 0):
    retVal = 0
    if channel < 0 or channel > 2:
      popup(vg_grip_bad_arg_channel, error = True)
      retVal = -99
    end
    if vacuum < 0 or vacuum > 80:
      popup(vg_grip_bad_arg_vacuum, error = True)
      retVal = -99
    end
    if retVal != 0:
      halt
    end
    if (tool_index == ON_DI_SECONDARY):
      local isPrimary = False
    else:
      local isPrimary = True
    end
    #if (on_follow_tcp):
    #  on_tcp_set_actual_to(isPrimary)
    #end
    vg_enabled_arr[tool_index] = True
    local err = on_tool_xmlrpc.vg10_grip(tool_index, channel, vacuum * 1.0)
    if err < 0:
      popup(vg_grip_error_command, title = vg_grip_message_title, error = True, blocking = False)
      halt
    end
    if timeout > 0.0:
      vg_glob_time = 0.0
      while (((channel == 0 or channel == 2) and vg_Vacuum_A_arr[tool_index] < vacuum) or ((channel == 1 or channel == 2) and vg_Vacuum_B_arr[tool_index] < vacuum)):
        if vg_glob_time > timeout:
          popup(vg_grip_could_not_reach_vacuum, title = vg_grip_message_title, error = True, blocking = False)
          vg_release(channel, tool_index = tool_index)
          halt
        end
        sync()
      end
    else:
      alert = False
    end
    if channel == 0 or channel == 2:
      vg_vacuum_guard_arr[0 + 2 * tool_index] = alert
    end
    if channel == 1 or channel == 2:
      vg_vacuum_guard_arr[1 + 2 * tool_index] = alert
    end
    #if (on_follow_tcp):
    #  on_tcp_update(isPrimary)
    #end
    return retVal
  end


  vg_release_message_title = "OnRobot - VG Release"
  vg_release_bad_channel = "vg_release : Please select channel 0, 1 or 2"
  vg_release_command_error = "Could not send release command. Please check connection.<br>Program halted."
  vg_release_failed = "Could not perform release. Please check power.<br>Program halted."
  vg_release_autoidle_not_supported = "vg_release: using autoidle=True is no longer supported"

  def vg_release(channel, timeout = 0.0, autoidle = False, tool_index = 0):
    if channel < 0 or channel > 2:
      popup(vg_release_bad_channel, title = vg_release_message_title, error = True, blocking = False)
      halt
    end
    if autoidle:
      popup(vg_release_autoidle_not_supported, title = vg_release_message_title, error = True, blocking = False)
      halt
    end
    if (tool_index == ON_DI_SECONDARY):
      local isPrimary = False
    else:
      local isPrimary = True
    end
    #if (on_follow_tcp):
    #  on_tcp_set_actual_to(isPrimary)
    #end
    vg_enabled_arr[tool_index] = True
    if channel == 0 or channel == 2:
      vg_vacuum_guard_arr[0 + 2 * tool_index] = False
    end
    if channel == 1 or channel == 2:
      vg_vacuum_guard_arr[1 + 2 * tool_index] = False
    end
    local release_A = channel == 0 or channel == 2
    local release_B = channel == 1 or channel == 2
    local err = on_tool_xmlrpc.vg10_release(tool_index, release_A, release_B)
    if err < 0:
      popup(vg_release_command_error, title = vg_release_message_title, error = True, blocking = False)
      halt
    else:
      if timeout > 0.0:
        vg_glob_time = 0.0
        while (((channel == 0 or channel == 2) and vg_Vacuum_A_arr[tool_index] > 1) or ((channel == 1 or channel == 2) and vg_Vacuum_B_arr[tool_index] > 1)):
          if vg_glob_time > timeout:
            popup(vg_release_failed, title = vg_release_message_title, error = True, blocking = False)
            halt
          end
          sync()
        end
      end
    end
    #if (on_follow_tcp):
    #  on_tcp_update(isPrimary)
    #end
    return 0
  end


  thread vg_grip_delayed_thread():
    local waitCntr = 0
    while (vg_grip_delayed_status != VG_GRIP_DELEAYED_STATUS_INIT):
      sync()
      if (waitCntr < 10):
        popup(vg_grip_delayed_start_fail, title = vg_grip_message_title, warning = True, blocking = True)
        halt
      else:
        waitCntr = waitCntr + 1
      end
    end
    vg_grip_delayed_status = VG_GRIP_DELEAYED_STATUS_START
    enter_critical
    local delay = vg_grip_delay
    local tool_index = vg_grip_delayed_tool_index
    local channel = vg_grip_delayed_channel
    local vacuum = vg_grip_delayed_vacuum
    local timeout = vg_grip_delayed_timeout
    local alert = vg_grip_delayed_alert
    local mass = vg_grip_delayed_mass
    exit_critical
    vg_grip_delayed_status = VG_GRIP_DELEAYED_STATUS_IDLE
    local sleepTime = 0.01
    while (delay > 0):
      sleep(sleepTime)
      delay = delay - sleepTime
    end
    on_return = vg_grip(channel, vacuum, timeout, alert, tool_index)
    #vg_payload_set(mass, channel, tool_index)
  end


  def vg_grip_delayed(tool_index = 0, channel = 2, vacuum = 60, timeout = 3.0, alert = True, delay = 0, mass = 0):
    if (delay > 0):
      sync()
      local waitCntr = 0
      while (vg_grip_delayed_status != VG_GRIP_DELEAYED_STATUS_IDLE):
        sync()
        if (waitCntr < 10):
          popup(vg_grip_delayed_init_fail, title = vg_grip_message_title, warning = True, blocking = True)
          halt
        else:
          waitCntr = waitCntr + 1
        end
      end
      vg_grip_delayed_status = VG_GRIP_DELEAYED_STATUS_START
      enter_critical
      vg_grip_delay = delay
      vg_grip_delayed_tool_index = tool_index
      vg_grip_delayed_channel = channel
      vg_grip_delayed_vacuum = vacuum
      vg_grip_delayed_timeout = timeout
      vg_grip_delayed_alert = alert
      vg_grip_delayed_mass = mass
      exit_critical
      vg_grip_delayed_status = VG_GRIP_DELEAYED_STATUS_INIT
      vg_grip_delayed_thread_handler[tool_index] = run vg_grip_delayed_thread()
      sync()
    else:
      on_return = vg_grip(channel, vacuum, timeout, alert, tool_index)
      #vg_payload_set(mass, channel, tool_index)
    end
  end
 




  def vg_seek(tool_index):
    local retVal = 0
    zero_ftsensor()
    #if (on_follow_tcp):
    #  if (tool_index == ON_DI_SECONDARY):
    #    local isPrimary = False
    #  else:
    #    local isPrimary = True
    #  end
    #  on_tcp_set_actual_to(isPrimary)
    #end
    local actual_tcp = on_get_tcp_for(tool_index)
    local p0 = pose_trans(get_actual_tool_flange_pose(), actual_tcp)
    force_mode(p0, [0, 0, 1, 0, 0, 0], [0, 0, 10, 0, 0, 0], 2, [1, 1, 0.1, d2r(10), d2r(10), 1])
    sleep(0.10)
    while True:
      v = get_actual_tcp_speed()
      if (norm([v[0],v[1],v[2]]) < 0.003) and (norm([v[3], v[4], v[5]]) < 0.005):
        end_force_mode()
        break
      else:
        local p1 = pose_trans(get_actual_tool_flange_pose(), actual_tcp)
        if (point_dist(p0, p1) > 0.1):
          end_force_mode()
          popup(vg_grip_no_part, title = vg_grip_message_title, warning = True, blocking = True)
          retVal = 1
          break
        else:
          sync()
        end
      end
    end
    return retVal
  end





  # ===================== ACTION DEF - END =========================== #
  # ===================== INIT - START =============================== #

  def done_waiting_for_init(device_name, product_code, tool_index = 0):
    textmsg(str_cat(device_name, str_cat(str_cat("[", tool_index), "]: ")), product_code)
  end
  
  def vg_wait_for_init(tool_index):
    local vg_timeout = 0
    while not(vg_product_code_arr[tool_index] == VG_DEVICE_ID_VG10 or vg_product_code_arr[tool_index] == VG_DEVICE_ID_VGC10):
      sync()
      vg_timeout = vg_timeout + 1
      if (vg_timeout > ON_INIT_TIMEOUT):
        popup(vg_device_id_timeout, vg_error_title, error = True, blocking = False)
        halt
      end
    end
    done_waiting_for_init("VG", vg_product_code_arr[tool_index], tool_index)
  end

  sync()
  textmsg(on_xmlrpc_start_ip, on_conn_ip)
  if (ON_REG_USE_TOOL):
    on_regStart_conn = [ON_CONN_SHIFT_BOOL, ON_CONN_SHIFT_INT, ON_CONN_SHIFT_FLOAT]
    on_regSum_conn = [ON_CONN_REG_SUM_BOOL, ON_CONN_REG_SUM_INT, ON_CONN_REG_SUM_FLOAT]
    on_rtde_feed_open(on_conn_ip, on_conn_rtde_feed_name, on_regStart_conn, on_regSum_conn, ON_REGISTERS_SPEEDL_FLOAT)
    sync()
    textmsg(on_xmlrpc_start_ip, on_tool_ip)
    on_regStart_tool = [ON_TOOL_SHIFT_BOOL, ON_TOOL_SHIFT_INT, ON_TOOL_SHIFT_FLOAT]
    on_regSum_tool = [ON_TOOL_REG_SUM_BOOL, ON_TOOL_REG_SUM_INT, ON_TOOL_REG_SUM_FLOAT]
    on_rtde_feed_open(on_tool_ip, on_tool_rtde_feed_name, on_regStart_tool, on_regSum_tool, 0)
    sync()
  else:
    on_regStart_conn = [ON_CONN_SHIFT_BOOL, ON_CONN_SHIFT_INT, ON_CONN_SHIFT_FLOAT]
    on_regSum_conn = [ON_CONN_REG_SUM_BOOL, ON_CONN_REG_SUM_INT, ON_CONN_REG_SUM_FLOAT]
    on_rtde_feed_open(on_conn_ip, on_conn_rtde_feed_name, on_regStart_conn, on_regSum_conn, ON_REGISTERS_SPEEDL_FLOAT)
    sync()
  end
  on_set_rtde_watchdog(updateHz = 0.2)
  sync()
  vg_dataRead_running = True
  sync()
  vg_dataRead_thrd = run vg_dataRead_thread()
  sync()
  textmsg(vg_device_id_waiting)
  if (vg_index == ON_DI_DUAL):
    vg_wait_for_init(ON_DI_PRIMARY)
    vg_wait_for_init(ON_DI_SECONDARY)
  else:
    vg_wait_for_init(vg_index)
  end


  # ===================== INIT - END ================================= #
  # ===================== RUN PROGRAM - START ======================== #


  # ===================== RUN PROGRAM - END ========================== #

end
